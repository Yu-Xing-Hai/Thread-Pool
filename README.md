# 一、学习目标​​
- 掌握现代C++核心特性：std::thread、std::mutex、std::future
- 理解生产者-消费者模型（工业控制核心模式）
- 培养资源管理意识（避免线程泄漏）
# 二、分步指南
1. **基础版本**（3天）  【√】
   - 用`std::queue`实现任务队列
   - 通过`std::condition_variable`实现任务调度
   - 支持固定线程数（如4个worker线程）

2. **进阶优化**（5天）  
   - 实现动态扩容：根据队列负载自动增减线程  
   - 集成性能监控：统计任务平均耗时/队列积压量  
   - 添加优雅退出机制：处理未完成任务  

3. **工程化扩展**（2天）  
   - 编写单元测试（Google Test验证线程安全）  
   - 输出性能对比报告（对比直接创建线程的差异）  
# 三、线程池的核心原理
> 线程池是一种多线程资源管理技术，通过创建一组线程并复用，减少频繁创建/销毁线程的开销
- 核心目标
  - 线程复用：避免线程重复创建、降低系统资源消耗
  - 任务队列管理：通过缓冲队列调度任务，防止任务堆积导致内存溢出
  - 并发控制：限制同时活跃的线程数，防止资源竞争和上下文切换过载
# 四、线程池的核心模块
## 4.1  任务队列【核心数据结构】
- 功能
  - 存储待执行任务，避免频繁创建线程执行一个单独任务，保持线程复用，通常使用线程安全的队列(如std::queue或者优先队列)
- 实现要点
  - 使用模板template支持多种任务类型
  - 结合互斥锁和条件变量实现线程安全操作
## 4.2  工作线程组【狭义上的线程池】
- 功能
  - **预创建的线程**循环执行队列中的任务
- 实现要点
  - 线程在空闲时通过条件变量阻塞，等待任务唤醒
## 4.3  同步机制
- 互斥锁mutex
- 条件变量Condition_virable
- 原子变量atomic
  - 用于管理线程池状态
# 五、高级优化方向
- 加入CUDA并行？【待尝试】
- 任务优先级调度
  - 使用优先队列实现高优先级任务优先执行
- Work Stealing
  - 允许空闲线程从其他线程的任务队列中“stealing”任务，提升负载均衡
- 动态线程调整
  - 根据任务负载动态增减线程数量，避免资源浪费
- 异常处理与日志
  - 捕获任务执行中的异常，防止线程意外终止，并记录日志便于调试
# 六、项目实践建议
- 测试用例设计
  - 验证并发任务执行顺序
  - 压测：模拟高并发场景下的性能
  - 边界测试：空队列、线程池关闭后提交任务等异常情况
- 性能调优
  - 使用无锁队列减少锁竞争
  - 绑定线程到特定CPU，减少上下文切换
- 拓展
  - 支持GPU任务与异构计算

# 七、代码风格
- 使用LLVM基础风格 + 自定义大括号规则
- 格式化命令：`clang-format -i **/*.cpp **/*.h`