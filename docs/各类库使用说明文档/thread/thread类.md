## thread类与相关函数使用
- thread类的作用
  - 封装操作系统线程，提供跨平台的多线程操作接口
- 核心操作
  - 构造线程对象
    - 绑定一个可调用对象(函数、Lambda、函数对象等)启动线程
    - 构造函数接受一个可调用对象及其参数，**无需显式指定模板参数，编译器会自动推导类型**
      - 因为构造函数是模板函数，所以能够自动推导可调用对象类型
  - 等待线程结束
    - 通过`join()`方法阻塞当前主线程，直到目标线程执行完毕
      - 阻塞调用者
        - 调用`t.join()`的线程会暂停，直到线程t的任务执行完成
      - **资源回收**
        - `join()`会确保子线程结束后，其占用的系统资源(如栈内存、线程句柄)被正确释放，进而继续执行当前主线程
          - 趣味一句话记住​​：join() 就是主线程对子线程说：“我等你做完，再一起走！”
        - 如果不调用 join() 会发生什么？
          - 未回收资源
            - 如果线程对象析构前未调用 join() 或 detach()，程序会调用 std::terminate() 强制终止（引发崩溃）
          - 未定义行为
            - 子线程可能仍在运行，但主线程已退出，导致数据竞争或资源泄漏
      - 一次调用
        - 每个线程对象只能调用一次该函数，重复调用会导致程序奔溃
    - 如何检查线程是否可`join()`
      - 使用`joinable()`方法，如：`if (threadOne.joinable()) threadOne.join();`
  - 分离线程
    - 通过`detach()`方法让线程在后台独立运行(失去对线程的控制权，如日志记录)
## 注意事项
- 线程对象的存储
  - 优先使用栈存储，堆存储需要配合智能指针实现，栈分配是主流​​，适用于 90% 的线程场景，简单安全
    - RAII原则
      - 栈对象自动调用析构函数，确保资源释放(如文件句柄、锁、线程)
    - 减少错误
      - 避免手动管理导致的泄漏或悬空指针
    - 与标准库一致
      - std::vector、std::string 也默认推荐栈分配
- 线程的拷贝与移动
  - 线程不可拷贝，但可以通过`std:move()`转移所有权
- 参数传递
  - 默认行为
    - 参数会被拷贝到线程的存储空间中
  - 传递变量左值引用
    - 需使用`std::ref`进行包装传递：
- 资源回收
  - 线程对象析构前必须调用`join()`或`detach()`，否则程序终止